<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sine Wave Interference Warbling Demonstration</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>Sine Wave Interference Warbling</h1>
    <p>Audio waves of different frequencies blend together and cancel each other out. The closer two frequencies are, the slower the warbling.</p>
    
    <div id="controls">
      <div class="control-group">
        <label for="frequency1">Frequency 1:</label>
        <input type="range" id="frequency1" min="0" max="20000" value="115" step="1">
        <input type="text" id="frequency1-display" value="115">
        <span>Hz</span>
      </div>
      <div class="control-group">
        <label for="frequency2">Frequency 2:</label>
        <input type="range" id="frequency2" min="0" max="20000" value="290" step="1">
        <input type="text" id="frequency2-display" value="290">
        <span>Hz</span>
      </div>
    </div>
    
    <button id="mute-button">Mute</button>
    
    <div class="canvas-container">
      <h3>Time Domain</h3>
      <canvas id="waveform" width="700" height="140"></canvas>
    </div>
    
    <div class="canvas-container">
      <h3>Frequency Domain</h3>
      <canvas id="frequencyform" width="700" height="140"></canvas>
    </div>

    <h3>Try These Combinations</h3>
    <div class="button-row">
      <button class="set-frequency" data-freq1="129" data-freq2="130">129 & 130 Hz</button>
      <button class="set-frequency" data-freq1="129" data-freq2="131">129 & 131 Hz</button>
      <button class="set-frequency" data-freq1="129" data-freq2="129.1">129 & 129.1 Hz</button>
    </div>
    <p class="hint-text">(Wait it out for 129.1 Hz to notice changes)</p>

    <div class="info-section">
      <p><strong>Singers use sine waves to train pitch accuracy</strong> by minimizing warbling. Made with ChatGPT.</p>
    </div> 
  
  <script>
    var canvasTime = document.getElementById('waveform');
    var canvasFreq = document.getElementById('frequencyform');
    var frequency1Slider = document.getElementById('frequency1');
    var frequency1Display = document.getElementById('frequency1-display');
    var frequency2Slider = document.getElementById('frequency2');
    var frequency2Display = document.getElementById('frequency2-display');
    var muteButton = document.getElementById('mute-button');

    var audioContext = new AudioContext();

    var oscillator1 = audioContext.createOscillator();
    var oscillator2 = audioContext.createOscillator();

    var gainNode = audioContext.createGain();

    oscillator1.frequency.value = frequency1Slider.value;
    oscillator2.frequency.value = frequency2Slider.value;

    oscillator1.connect(gainNode);
    oscillator2.connect(gainNode);

    gainNode.connect(audioContext.destination);

    oscillator1.start();
    oscillator2.start();

    var analyser = audioContext.createAnalyser();
    gainNode.connect(analyser);

    // Track frequencies and cached min/max for stable scaling
    var currentFreq1 = parseFloat(frequency1Slider.value);
    var currentFreq2 = parseFloat(frequency2Slider.value);
    var cachedMin = 0;
    var cachedMax = 255;
    var scaleUpdateFrames = 0;
    var maxScaleUpdateFrames = 600; // Sample for 10 seconds at 60fps to capture slow beat frequencies

    function updateWaveformScale(data) {
      // Accumulate min/max over multiple frames
      for (var i = 0; i < data.length; i++) {
        if (data[i] < cachedMin) cachedMin = data[i];
        if (data[i] > cachedMax) cachedMax = data[i];
      }
    }

    function drawTimeDomain() {
      var data = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteTimeDomainData(data);

      var ctx = canvasTime.getContext('2d');
      ctx.clearRect(0, 0, canvasTime.width, canvasTime.height);
      ctx.beginPath();
      
      var width = canvasTime.width;
      var height = canvasTime.height;
      var sliceWidth = width * 1.0 / data.length;
      var x = 0;

      // Check if frequencies changed
      var newFreq1 = parseFloat(frequency1Slider.value);
      var newFreq2 = parseFloat(frequency2Slider.value);
      
      if (newFreq1 !== currentFreq1 || newFreq2 !== currentFreq2) {
        currentFreq1 = newFreq1;
        currentFreq2 = newFreq2;
        scaleUpdateFrames = 0;
        // Reset cached values to force recalculation
        cachedMin = 255;
        cachedMax = 0;
      }

      // Update scale only when frequencies change or during initial sampling period
      if (scaleUpdateFrames < maxScaleUpdateFrames) {
        updateWaveformScale(data);
        scaleUpdateFrames++;
      }
      
      // Use cached values if valid, otherwise use current frame's data
      var useCached = cachedMax > cachedMin && scaleUpdateFrames >= maxScaleUpdateFrames;
      var min = useCached ? cachedMin : 255;
      var max = useCached ? cachedMax : 0;
      
      // If not using cached, get current frame's range
      if (!useCached) {
        for (var i = 0; i < data.length; i++) {
          if (data[i] < min) min = data[i];
          if (data[i] > max) max = data[i];
        }
      }
      
      // Check current frame for values outside cached range and expand if needed
      if (useCached) {
        var currentMin = 255;
        var currentMax = 0;
        for (var i = 0; i < data.length; i++) {
          if (data[i] < currentMin) currentMin = data[i];
          if (data[i] > currentMax) currentMax = data[i];
        }
        // Expand cached range if current frame exceeds it, and update cache
        if (currentMin < cachedMin) {
          cachedMin = currentMin;
          min = currentMin;
        }
        if (currentMax > cachedMax) {
          cachedMax = currentMax;
          max = currentMax;
        }
      }
      
      // Add very generous padding to the range to prevent clipping (50% on each side)
      // This ensures we have plenty of headroom for peaks that might exceed sampled values
      var rangePadding = Math.max((max - min) * 0.5, 20); // At least 20 units of padding
      var adjustedMin = Math.max(0, min - rangePadding);
      var adjustedMax = Math.min(255, max + rangePadding);
      var range = adjustedMax - adjustedMin;
      
      // Canvas padding (8% on top and bottom for extra headroom)
      var padding = height * 0.08;
      var availableHeight = height - (padding * 2);

      ctx.strokeStyle = '#818cf8';
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.shadowBlur = 10;
      ctx.shadowColor = 'rgba(129, 140, 248, 0.6)';

      for (var i = 1; i < data.length; i++) {
        // Normalize to 0-1 range based on adjusted min/max, then scale to fit canvas
        var normalized = range > 0 ? (data[i] - adjustedMin) / range : 0.5;
        var y = padding + (normalized * availableHeight);

        if(i === 1) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }

        x += sliceWidth;
      }

      ctx.stroke();
      requestAnimationFrame(drawTimeDomain);
    }

    function drawFrequencyDomain() {
      var data = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(data);

      var ctx = canvasFreq.getContext('2d');
      ctx.clearRect(0, 0, canvasFreq.width, canvasFreq.height);
      var barWidth = (canvasFreq.width / data.length) * 2.5;
      var barHeight;
      var x = 0;
      var maxHeight = canvasFreq.height;

      for(var i = 0; i < data.length; i++) {
        barHeight = (data[i] / 255) * maxHeight;
        
        // Create gradient from indigo to pink matching the theme
        var gradient = ctx.createLinearGradient(0, maxHeight - barHeight, 0, maxHeight);
        gradient.addColorStop(0, '#818cf8');
        gradient.addColorStop(0.5, '#a78bfa');
        gradient.addColorStop(1, '#ec4899');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x, maxHeight - barHeight, barWidth, barHeight);
        x += barWidth + 1;
      }

      requestAnimationFrame(drawFrequencyDomain);
    }

    drawTimeDomain();
    drawFrequencyDomain();

    frequency1Slider.addEventListener('input', function() {
      oscillator1.frequency.value = frequency1Slider.value;
      frequency1Display.value = frequency1Slider.value;  
    });

    frequency2Slider.addEventListener('input', function() {
      oscillator2.frequency.value = frequency2Slider.value;
      frequency2Display.value = frequency2Slider.value;  
    });

    frequency1Display.addEventListener('input', function() {
      frequency1Slider.value = frequency1Display.value;
      oscillator1.frequency.value = frequency1Display.value;
    });

    frequency2Display.addEventListener('input', function() {
      frequency2Slider.value = frequency2Display.value;
      oscillator2.frequency.value = frequency2Display.value;
    });

    muteButton.addEventListener('click', function() {
      if (muteButton.textContent === 'Mute') {
        gainNode.gain.value = 0;
        muteButton.textContent = 'Unmute';
      } else {
        gainNode.gain.value = 1;
        muteButton.textContent = 'Mute';
      }
    });

    function startAudio() {
      audioContext.resume().then(() => {
        // start the oscillators and draw the waveform here
      });
    }

    document.addEventListener('click', startAudio);

    document.querySelectorAll('.set-frequency').forEach(button => {
    button.addEventListener('click', function() {
        // Get the frequencies from the data attributes
        let freq1 = this.getAttribute('data-freq1');
        let freq2 = this.getAttribute('data-freq2');

        // Set the oscillator frequencies
        oscillator1.frequency.value = freq1;
        oscillator2.frequency.value = freq2;

        // Update the slider and display values
        frequency1Slider.value = freq1;
        frequency2Slider.value = freq2;
        frequency1Display.value = freq1;
        frequency2Display.value = freq2;
      });
    });
  </script>
</body>
</html>
